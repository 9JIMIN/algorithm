# 다이나믹-1

- [1로 만들기](#1로-만들기)
- [2n 타일링](#2n-타일링)



## 1로 만들기

> 1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
> 2. X가 2로 나누어 떨어지면, 2로 나눈다.
> 3. 1을 뺀다.
>
> - 입력: 10
> - 출력: 3
>
> 연산의 최솟값을 출력

10 - 9 - 3 - 1 로 세번의 연산을 거친다. 

재귀함수를 써서, 주어진 10부터 계산하는 것이 아니라, 처음 1, 2 여기서 부터 시작한다. 
이걸 bottom-up 방식이라고 하더라..

처음 밑바닥부터, 최적의 경로를 찾아가는 방식으로 풀어야함.

만약, 10 이 주어지면, **1,2가 나올때까지** 2와 3으로 나눔.
그리고 거기서부터 나머지를 더해가면서, 최솟값을 찾아나가는 방식

답안

```python
def f(n):
    if n <= 2: return n-1
    return 1 + min(f(n//3)+n%3, f(n//2)+n%2)
print(f(int(input())))
```

람다로 더 깔끔하게 

```python
f=lambda n:n-1 if n<3 else 1+min(f(n//2)+n%2,f(n//3)+n%3)
print(f(int(input())))
```



## 2n 타일링

> - n이 주어졌을때, 2 * n의 직사각형을 1 * 2, 2 * 1로 채우는 방법의 수를 출력
> - 9 => 55
>
> 출력값 =  방법수%10007

1 = 1
2 = 2
3 = 3
4 = 5
5 = 8

쭉 - 나열하다보면 f(n) = f(n-1) + f(n-2)의 합이라는 규칙이 보임.
이걸 a, b = b, a+b 식으로 나타낼 수 있음. 

이걸 n번 반복하면 됨.

답안

```python
a,b = 1,1
for i in range(int(input())): a,b = b,a+b
print(a%10007) 
```

