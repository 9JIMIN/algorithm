# 다이나믹-1

- [1로 만들기](#1로-만들기)
- [2n 타일링](#2n-타일링)
- [2n 타일링2](#2n-타일링2)
- [1,2,3 더하기](#1,2,3-더하기)
- [카드구매하기](#카드구매하기)
- [1,2,3 더하기5](#1,2,3-더하기)
- [쉬운계단수](#쉬운계단수)
- [이친수](#이친수)
- [연속합](#연속합)
- [lis-1](#lis-1)
- [lis-4](#lis-4)
- [제곱수의 합](#제곱수의-합)
- [합분해](#합분해)



## 1로 만들기

> 1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
> 2. X가 2로 나누어 떨어지면, 2로 나눈다.
> 3. 1을 뺀다.
>
> - 입력: 10
> - 출력: 3
>
> 1로 만들기 위한, 연산의 최소 횟수를 출력

10 -> 9 -> 3 -> 1 로 세번의 연산을 거친다. 

재귀함수를 써서, 주어진 10부터 계산하는 것이 아니라, 처음 1, 2 여기서 부터 시작한다. 
이걸 bottom-up 방식이라고 하더라..

처음 밑바닥부터, 최적의 경로를 찾아가는 방식으로 풀어야함.

만약, 10 이 주어지면, **1,2가 나올때까지** 2와 3으로 나눔.
그리고 거기서부터 나머지를 더해가면서, 최솟값을 찾아나가는 방식

답안

```python
def f(n):
    if n <= 2: return n-1
    return 1 + min(f(n//3)+n%3, f(n//2)+n%2)
print(f(int(input())))
```

람다로 더 깔끔하게 

```python
f=lambda n:n-1 if n<3 else 1+min(f(n//2)+n%2,f(n//3)+n%3)
print(f(int(input())))
```



## 2n 타일링

> - n이 주어졌을때, 2 * n의 직사각형을 1 * 2, 2 * 1로 채우는 방법의 수를 출력
> - 9 => 55
>
> 출력값 =  방법수%10007

1 = 1
2 = 2
3 = 3
4 = 5
5 = 8

쭉 - 나열하다보면 f(n) = f(n-1) + f(n-2)의 합이라는 규칙이 보임.
이걸 간단한 재귀식인 a, b = b, a+b 으로 나타낼 수 있음. 

이걸 n번 반복하면 됨.

답안

```python
a,b = 1,1
for i in range(int(input())): a,b = b,a+b
print(a%10007) 
```



## 2n 타일링2

> 2*2타일도 넣을 수 있을때, 2\*n의 직사각형을 채우는 방법수.

1=1
2=3
3=5
4=11
5=21
...
규칙이 f(n) = f(n-1)+2*f(n-2) 이다. 

```python
def f(n):
    if n == 1: return 1
    elif n == 2: return 3
    else: return f(n-1)+2*f(n-2)

print(f(int(input()))%10007)
```

이렇게 풀면, 1000이전까지만 가능하다. 
왜냐하면 파이썬은 재귀를 1000으로 제한 하거든.

그래서 이전 타일링 문제처럼 반복문으로 만들어야함.

답안

```python
a,b=1,3
for _ in range(int(input())-1):
    a, b = b, 2*a+b
print(a%10007)
```

이 방법은 이전 재귀처럼 top-down이 아니라, bottom-up이기 때문에 더 좋다고 볼 수 있다. 

이전 방법은 100이 주어지면, 99랑 98을 찾고.. 했는데.
이번 방법은 100이 주어지면, 1부터 올라감. 
다이나믹은 항상 bottom-up이 옳다!



## 1,2,3 더하기

> 1,2,3의 합으로 만들 수 있는 경우의 수를 출력
> 조합의 순서가 달라도 다른 것으로 인정. ex) 1+2, 2+1

1=1
2=2
3=4
4=7
5=13
6=24
...
f(n) = f(n-1)+f(n-2)+f(n-3)

답안

```python
N = int(input())
def f(n):
    if n == 1: return 1
    elif n == 2: return 2
    elif n == 3: return 4
    else: return f(n-1)+f(n-2)+f(n-3)

for _ in range(N): print(f(int(input())))
```

bottom-up으로 하면..

```python
N = int(input())
for _ in range(N):
    a, b, c = 0, 0, 1
    for _ in range(int(input())): a, b, c = b, c, a+b+c
    print(c)
```



## 카드구매하기

> 주어진 숫자만큼의 카드를 가장 비싸게 구매할때의 가격
>
> - 4
>   1 5 6 7 
>   1장든 팩은 1원, 2장 팩은 5원, 2장은 6원....
> - 10 
>   4장의 카드를 가장 비싸게 사는 방법은 2팩을 2개 사서 10원에 사는 것. 10을 출력

카드 1개를 사는 가장 비싼 값(최고가)부터 해서..  2, 3개.. 의 최고가를 구해서 리스트에 추가. 
그렇게 n개의 방법을 구하는 bottom-up방식.

리스트에 1개를 사는 최고가부터 넣어두고, 
n개의 최고가를 알기 위해서 

- 1개의 최고가에 n-1개 팩의 가격을 더한 값 
- 2개의 최고가에 n-2개 팩의 가격을 더한 값
- ...
- n개 팩의 값

이중에서 가장 큰 값을 리스트에 더하는 하는 방식.
이걸 n까지 하면, 마지막 리스트값이 n개를 가장 비싸게 살때의 값이 됨.
min으로 하면 반대로 가장 싸게 사는 방법.

답안

```python
n = int(input())
price = list(map(int, input().split()))

ans = [0]
for i in range(1,n+1):
    ans.append(max(ans[i-j-1] + price[j] for j in range(i)))
print(ans[-1])
```



## 1,2,3 더하기5

> - 3 // 케이스 개수
>   4
>   7
>   10
> - 3
>   9
>   27
>
> 1,2,3의 합으로 나타냄. 같은 숫자가 두 번 이상 연속 올 수 없음.
> 방법의 수를 1000000009로 나눈 값을 출력

1,2,3 각 숫자로 시작하는 조합의 수

n의 1로 시작하는 조합은 n-1에서 1로 시작하는 조합을 제외한 조합들의 합
n의 2로 시작하는 조합은 n-2에서 2로 시작하는 조합을 제외한 조합들의 합 
n의 3로 시작하는 조합은 n-3에서 3로 시작하는 조합을 제외한 조합들의 합 

이전 값을 참고하기에 리스트에 저장을 해야하고, 다이나믹으로 풀어야한다.

DP[0] = [0, 0, 0]
DP[1] = [1, 0, 0] // (1)
DP[2] = [0, 1, 0] // (2)
DP[3] = [1, 1, 1] // (1+2) | (2+1) | (3)
DP[4] = [2, 0, 1] // (1+2+1),(1+3) | (3,1)
DP[5] = [1, 2, 1] // (1+3+1) | (2+1+2),(2+3) | (3,2)
DP[6] = [3, 3, 2]...

답안

```python
DP = [[0]*3 for _ in range(100001)]
DP[0] = [1,0,0]
DP[1] = [0,1,0]
DP[2] = [1,1,1]

for i in range(3,100001):
    DP[i][0] = (DP[i-1][1] + DP[i-1][2])%1000000009
    DP[i][1] = (DP[i-2][0] + DP[i-2][2])%1000000009
    DP[i][2] = (DP[i-3][0] + DP[i-3][1])%1000000009

for _ in range(int(input())):
    print(sum(DP[int(input())-1])%1000000009)
```



## 쉬운계단수

> 45656이란 수를 보자.
> 이 수는 인접한 모든 자리수의 차이가 1이 난다. 이런 수를 계단 수라고 한다.
> N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구하는 프로그램을 작성하시오. (0으로 시작하는 수는 없다.)
>
> - 2 // 1~100의 자연수
> - 17 // 개수를 1,000,000,000으로 나눈 나머지

끝자리 0~9의 각 자리에서의 방법수를 기록하는 리스트를 만든다. 
n이 주어질때, 각 끝자리에 대한 방법의 수는 n-1에서 해당 자리수 양옆의 자리수에 대한 방법수의 합이다. 
단, 0, 9에서는 한 쪽만 가져온다.

이렇듯, 문제에서 어떤 값이 앞선 값과 관계가 있을때는 각 자리수와 같은 **부분으로 나눠서 점화식**을 세워보는 것이 중요.

답안

```python
num = [[0 for _ in range(10)] for _ in range(100)]

for i in range(1, 101):
	for j in range(10):
		if i == 1:
			num[i][j] = 1
		else:
			if 1 <= i <= 8:
				num[i][j] = num[i-1][j-1] + num[i-1][j+1]
			elif i == 0:
				num[i][j] = num[i-1][j+1]
			elif i == 9:
				num[i][j] = num[i-1][j-1]
n = int(input())
print(sum(num[n][1:10]) % 1000000000)
```



## 이친수

> 0과 1로만 이루어진 수를 이진수라 한다. 이러한 이진수 중 특별한 성질을 갖는 것들이 있는데, 이들을 이친수(pinary number)라 한다. 이친수는 다음의 성질을 만족한다.
>
> 1. 이친수는 0으로 시작하지 않는다.
> 2. 이친수에서는 1이 두 번 연속으로 나타나지 않는다. 즉, 11을 부분 문자열로 갖지 않는다.
>
> 예를 들면 1, 10, 100, 101, 1000, 1001 등이 이친수가 된다. 하지만 0010101이나 101101은 각각 1, 2번 규칙에 위배되므로 이친수가 아니다.
>
> N(1 ≤ N ≤ 90)이 주어졌을 때, N자리 이친수의 개수를 구하는 프로그램을 작성하시오.
>
> - 3
> - 2 // 101, 100

3의 이친수를 구할 때는 3-1의 이친수의 끝자리를 보고, 
0이면 1과 0을 덧붙여서 두개를 더 만들 수 있고, 
1이면 0을 붙여서 하나를 만들 수 있다.

그러니까 이친수의 끝숫자인 0과 1의 개수만 알면 된다.
90개의 0과1의 개수를 기록하는 리스트를 만들고,

이전 값의 0개수만큼을 현재값의 0개수와 1개수에 더하고,
이전 값의 1개수만큼을 현재값의 0개수에 더한다.

답안

```python
d = [[0, 0] for _ in range(91)]
d[1] = [0, 1]
for i in range(2, 91):
    d[i][0] = d[i-1][0]+d[i-1][1]
    d[i][1] = d[i-1][0]

n = int(input())
print(sum(d[n]))
```



## 연속합

> n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다.
>
> 예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자. 여기서 정답은 12+21인 33이 정답이 된다.
>
> - 10
> - 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 // -1000<= x <=1000

중요한 것은 **연속한** 수열의 합이라는 것.

수열을 순회하면서 **i에서의 최댓값은 i-1까지의 최댓값에서 i값을 더한 값, i값중 더 큰 값이 된다.**

답안

```python
n = int(input())
num = list(map(int, input().split()))
d = [0 for _ in range(n)]

for i in range(n):
    d[i] = max(d[i-1] + num[i], num[i])

ans = max(d)
print(ans)
```



## lis-1

> 수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.
>
> 예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {**10**, **20**, 10, **30**, 20, **50**} 이고, 길이는 4이다.
>
> - 6
>   10 20 10 30 20 50
> - 4

일단, 받은 수열길이 만큼의 d=[0]*n을 만든다.

주어진 수열을 순회할 때, 각 요소의 왼쪽 편 요소들을 순회한다. 
이중루프로 돌면서, 
**자기보다 작은 숫자들의 d값 중 최댓값에서 1을 더한다.**

`num[i] > num[j]` 중에서 d의 최댓값을 구하는 방법은 `d[i] < d[j]` 를 만족하는 d[j]를 d[i]로 교체해 나가면 된다.

```python
n = int(input())
num = list(map(int, input().split()))
d = [0]*n

for i in range(n):
    for j in range(i):
        if num[i] > num[j] and d[i] < d[j]:
            d[i] = d[j]
    d[i] += 1

print(max(d)) 
```

위 방법은 n^2 복잡도를 가진다. 

d[i]을 구하기위해 num[0] ~ num[i-1]까지 다 훑어볼 필요가 있을까?

**d[j] = k 를 만족하는 j 중 num[j] 값이 가장 작은 j만 따로 저장해 놓고, D[i]를 구할때 그 값들을 참조**만 하면 되지 않을까.

- [참고자료](https://namu.wiki/w/최장 증가 부분 수열) 

답안

```python
n = int(input())
num = list(map(int, input().split()))
d = {}

for x in num:
    d[sum(x > d[i] for i in d)] = x
print(len(d))

# sum([]) => 0
# sum([True, True, False]) => 2 
```



## lis-4

> 앞선 문제가 '가장 긴 증가하는 부분수열의' **길이**를 출력하는 문제였다면, 
> 이번 문제는 LIS, 수열을 출력하는 문제이다. 
>
> - 6
>   10 20 10 30 20 50
> - 4
>   10 20 30 50

앞에서 만든 알고리즘은 길이만 알 수 있지 수열 자체를 저장하지는 못한다.
수열까지 저장하기 위해서는 lis-1에서 처음쓴 이중 for문 방법이 필요함.

주어진 수열 A를 순회하면서 A[i] 에서 A[1] ~ A[i-1]를 검사. (이중 for문)
A[i] 보다 작은 A[j]에서 d가 가장 클 때의 j인덱스를 구함.

이걸 lis-1에서 처럼 try-catch, max가 아닌, if로 해결하는데 훨씬 깔끔함.

최장수열의 길이를 저장하는 d[i] 리스트에서 추가로, **res[i]리스트를 만들어서, 최장수열 '수열' 자체를 저장**함.
res[i] 는 A[i]로 끝나는 최대증가부분수열.

```python
# ex
>>> 6
>>> 1 2 1 3 2 5

# print(res)
[[1], [1, 2], [1], [1, 2, 3], [1, 2], [1, 2, 3, 5]]
# print(d)
[1, 2, 1, 3, 2, 4]
```

그럼, res리스트에서 최장 길이를 가진 리스트가 답이 됨.

답안

```python
n = int(input())
num = list(map(int, input().split()))
d = [0]*n
res = [[x] for x in num]

for i in range(n):
    for j in range(i):
        if num[i] > num[j] and d[i] < d[j]:
            d[i] = d[j]
            res[i] = res[j] + [num[i]]
    d[i] += 1
ans = max(d)
print(ans)
print(*res[d.index(ans)])
```



## 제곱수의 합

> 어떤 자연수 N은 그보다 작거나 같은 제곱수들의 합으로 나타낼 수 있다. 예를 들어 11=3^2+1^2+1^2(3개 항)이다. 이런 표현방법은 여러 가지가 될 수 있는데, 11의 경우 11=2^2+2^2+1^2+1^2+1^2(5개 항)도 가능하다. 이 경우, 11은 그보다 적은 항의 제곱수 합으로 표현할 수 없으므로, 11을 그 합으로써 표현할 수 있는 제곱수 항의 최소 개수는 3이다.
>
> 주어진 자연수 N을 이렇게 제곱수들의 합으로 표현할 때에 그 항의 최소개수를 구하는 프로그램을 작성하시오.
>
> - 7 // 100,000이하
> - 4 // 1의 제곱 3개, 2의 제곱하나 해서 4

1~10000**0.5까지의 숫자를 제곱한 값의 리스트를 만든다.
받은 숫자에 리스트 숫자를 하나씩 빼본다. 

이때, 뺀 값이 0보다 작을 경우의 이전 리스트값을 받은 숫자에서 뺀다. 
이걸 숫자가 0이 될때까지 반복한다.

라고 생각했다...

```python
n = int(input())
num = [i**2 for i in range(1, 318)]
c = 0
while n:
    for i in range(317):
        if n - num[i] < 0:
            n = n - num[i-1]
            c += 1
            break
print(c)
```

 맞다고 생각했는데, 이게 아니었다. 

예를 들어 32를 넣으면 위 알고리즘으로는 5가 나온다. 25+4+1+1+1
하지만 답은 2다. 16+16

그러니까, 무작정 큰 제곱수를 빼는 것이 답이 아니었다. 

예를 들어 **12에서 쓸 수 있는 제곱수는 1, 4, 9 이다. 그럼, 12의 제곱합은 12를 1, 4, 9로 뺀 값들의 제곱합 중에서 최솟값+1이다.**

```python
d[12] = min(d[12-1], d[12-4], d[12-9]) + 1
```

답안

```python
n = int(input())
d = [0]*(n+1)
for i in range(1, n+1):
    d[i] = min([d[i-j**2]+1 for j in range(1,int(i**0.5)+1)])
print(d[-1])
```



## 합분해

> 0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 프로그램을 작성하시오.
>
> 덧셈의 순서가 바뀐 경우는 다른 경우로 센다(1+2와 2+1은 서로 다른 경우). 또한 한 개의 수를 여러 번 쓸 수도 있다.
>
> - 20 2 // 첫째 줄에 두 정수 N(1 ≤ N ≤ 200), K(1 ≤ K ≤ 200)가 주어진다.
> - 21 // 첫째 줄에 답을 1,000,000,000으로 나눈 나머지를 출력한다.

n 2 의 경우의 수는 n+1이다. 

> 아래 방법은 진짜 삽질 그 자체니 그냥 넘어가도록 하자.

N이 10일때, K값에 따른 경우의 수, K가

1개의 경우의 수 1개
2개의 경우의 수 11개
3개의 경우의 수 11+10+9+ ... + 1
4개의 경우의 수 11\*1+10\*2 + 9\*3 + 8\*4... + 2\*10 + 1\*11
5개의 경우의 수 11\*1 + 10\*(1+2) + 9\*(1+2+3) + 8\*(1+2+3+4) + ... + 1*(1+2+ ... +11)

f(N, K)라고 할때, 
f(10, 0) = 0
f(10, 1) = 1
f(10, 2) = 11
f(10, 3) = 1\*f(10, 1) + 2*f(9, 1) + 3\*f(8, 1) + ... + 10\*f(1, 1) + 11\*f(0, 1)
f(10, 4) = 1\*f(10, 2) + 2\*f(9, 2) + 3\*f(8, 3) + ... + 10\*f(1, 3) + 11\*f(0, 3)

**f(N, K) = 1\*f(N, K-2) + 2\*f(N-1, K-2) + 3*f(N-2, K-2) + ... + N\*f(1, K-2) + (N+1)\*f(0, K-2)**

```python
N, K = map(int, input().split())

def f(n, k):
    if k == 1: return 1
    if k == 2: return n+1
    return sum([i*f(n+1-i, k-2) for i in range(1, n+2)])%1000000000

print(f(N, K))
```

위 알고리즘은 시간초과가 난다.

검색해보니, 2차원 DP로 푸는 방법이 있다. 
https://br-brg.tistory.com/18

N, K 두개의 값을 받으니까, 두 값을 축으로 그려보자.

| k\n   | **0** | **1** | **2** | **3** | **4** |
| ----- | ----- | ----- | ----- | ----- | ----- |
| **1** | 1     | 1     | 1     | 1     | 1     |
| **2** | 1     | 2     | 3     | 4     | 5     |
| **3** | 1     | 3     | 6     | 10    | 15    |

```python
f(n, k) = f(n-1, k) + f(n, k-1)
```

쉽게 점화식이 구해진다. 

이걸 인덱스를 조심하면서 구현하면 된다. 

```python
n, k = map(int, input().split())
d = [[1]*(n+1) for _ in range(k)]

for i in range(1, k):
    for j in range(1, n+1):
        d[i][j] = (d[i-1][j] + d[i][j-1])%1000000000

print(d[k-1][n])
```

변수가 두 개니까 2차원적으로 생각을 해야한다는 교훈..