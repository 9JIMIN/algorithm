# 다이나믹-1

- [1로 만들기](#1로-만들기)
- [2n 타일링](#2n-타일링)
- [2n 타일링2](#2n-타일링2)
- [1,2,3 더하기](#1,2,3-더하기)
- [카드구매하기](#카드구매하기)
- [1,2,3 더하기5](#1,2,3-더하기)
- [쉬운계단수](#쉬운계단수)



## 1로 만들기

> 1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
> 2. X가 2로 나누어 떨어지면, 2로 나눈다.
> 3. 1을 뺀다.
>
> - 입력: 10
> - 출력: 3
>
> 연산의 최솟값을 출력

10 - 9 - 3 - 1 로 세번의 연산을 거친다. 

재귀함수를 써서, 주어진 10부터 계산하는 것이 아니라, 처음 1, 2 여기서 부터 시작한다. 
이걸 bottom-up 방식이라고 하더라..

처음 밑바닥부터, 최적의 경로를 찾아가는 방식으로 풀어야함.

만약, 10 이 주어지면, **1,2가 나올때까지** 2와 3으로 나눔.
그리고 거기서부터 나머지를 더해가면서, 최솟값을 찾아나가는 방식

답안

```python
def f(n):
    if n <= 2: return n-1
    return 1 + min(f(n//3)+n%3, f(n//2)+n%2)
print(f(int(input())))
```

람다로 더 깔끔하게 

```python
f=lambda n:n-1 if n<3 else 1+min(f(n//2)+n%2,f(n//3)+n%3)
print(f(int(input())))
```



## 2n 타일링

> - n이 주어졌을때, 2 * n의 직사각형을 1 * 2, 2 * 1로 채우는 방법의 수를 출력
> - 9 => 55
>
> 출력값 =  방법수%10007

1 = 1
2 = 2
3 = 3
4 = 5
5 = 8

쭉 - 나열하다보면 f(n) = f(n-1) + f(n-2)의 합이라는 규칙이 보임.
이걸 간단한 재귀식인 a, b = b, a+b 으로 나타낼 수 있음. 

이걸 n번 반복하면 됨.

답안

```python
a,b = 1,1
for i in range(int(input())): a,b = b,a+b
print(a%10007) 
```



## 2n 타일링2

> 2*2타일도 넣을 수 있을때, 2\*n의 직사각형을 채우는 방법수.

1=1
2=3
3=5
4=11
5=21
...
규칙이 f(n) = f(n-1)+2*f(n-2) 이다. 

```python
def f(n):
    if n == 1: return 1
    elif n == 2: return 3
    else: return f(n-1)+2*f(n-2)

print(f(int(input()))%10007)
```

이렇게 풀면, 1000이전까지만 가능하다. 
왜냐하면 파이썬은 재귀를 1000으로 제한 하거든.

그래서 이전 타일링 문제처럼 반복문으로 만들어야함.

답안

```python
a,b=1,3
for _ in range(int(input())-1):
    a, b = b, 2*a+b
print(a%10007)
```

이 방법은 이전 재귀처럼 top-down이 아니라, bottom-up이기 때문에 더 좋다고 볼 수 있다. 

이전 방법은 100이 주어지면, 99랑 98을 찾고.. 했는데.
이번 방법은 100이 주어지면, 1부터 올라감. 
다이나믹은 항상 bottom-up이 옳다!



## 1,2,3 더하기

> 1,2,3의 합으로 만들 수 있는 경우의 수를 출력
> 조합의 순서가 달라도 다른 것으로 인정. ex) 1+2, 2+1

1=1
2=2
3=4
4=7
5=13
6=24
...
f(n) = f(n-1)+f(n-2)+f(n-3)

답안

```python
N = int(input())
def f(n):
    if n == 1: return 1
    elif n == 2: return 2
    elif n == 3: return 4
    else: return f(n-1)+f(n-2)+f(n-3)

for _ in range(N): print(f(int(input())))
```

bottom-up으로 하면..

```python
N = int(input())
for _ in range(N):
    a, b, c = 0, 0, 1
    for _ in range(int(input())): a, b, c = b, c, a+b+c
    print(c)
```



## 카드구매하기

> 주어진 숫자만큼의 카드를 가장 비싸게 구매할때의 가격
>
> - 4
>   1 5 6 7 
>   1장든 팩은 1원, 2장 팩은 5원, 2장은 6원....
> - 10 
>   4장의 카드를 가장 비싸게 사는 방법은 2팩을 2개 사서 10원에 사는 것. 10을 출력

카드 1개를 사는 가장 비싼 값(최고가)부터 해서..  2, 3개.. 의 최고가를 구해서 리스트에 추가. 
그렇게 n개의 방법을 구하는 bottom-up방식.

리스트에 1개를 사는 최고가부터 넣어두고, 
n개의 최고가를 알기 위해서 

- 1개의 최고가에 n-1개 팩의 가격을 더한 값 
- 2개의 최고가에 n-2개 팩의 가격을 더한 값
- ...
- n개 팩의 값

이중에서 가장 큰 값을 리스트에 더하는 하는 방식.
이걸 n까지 하면, 마지막 리스트값이 n개를 가장 비싸게 살때의 값이 됨.
min으로 하면 반대로 가장 싸게 사는 방법.

답안

```python
n = int(input())
price = list(map(int, input().split()))

ans = [0]
for i in range(1,n+1):
    ans.append(max(ans[i-j-1] + price[j] for j in range(i)))
print(ans[-1])
```



## 1,2,3 더하기5

> - 3 // 케이스 개수
>   4
>   7
>   10
> - 3
>   9
>   27
>
> 1,2,3의 합으로 나타냄. 같은 숫자가 두 번 이상 연속 올 수 없음.
> 방법의 수를 1000000009로 나눈 값을 출력

1,2,3 각 숫자로 시작하는 조합의 수

n의 1로 시작하는 조합은 n-1에서 1로 시작하는 조합을 제외한 조합들의 합
n의 2로 시작하는 조합은 n-2에서 2로 시작하는 조합을 제외한 조합들의 합 
n의 3로 시작하는 조합은 n-3에서 3로 시작하는 조합을 제외한 조합들의 합 

이전 값을 참고하기에 리스트에 저장을 해야하고, 다이나믹으로 풀어야한다.

DP[0] = [0, 0, 0]
DP[1] = [1, 0, 0] // (1)
DP[2] = [0, 1, 0] // (2)
DP[3] = [1, 1, 1] // (1+2) | (2+1) | (3)
DP[4] = [2, 0, 1] // (1+2+1),(1+3) | (3,1)
DP[5] = [1, 2, 1] // (1+3+1) | (2+1+2),(2+3) | (3,2)
DP[6] = [3, 3, 2]...

답안

```python
DP = [[0]*3 for _ in range(100001)]
DP[0] = [1,0,0]
DP[1] = [0,1,0]
DP[2] = [1,1,1]

for i in range(3,100001):
    DP[i][0] = (DP[i-1][1] + DP[i-1][2])%1000000009
    DP[i][1] = (DP[i-2][0] + DP[i-2][2])%1000000009
    DP[i][2] = (DP[i-3][0] + DP[i-3][1])%1000000009

for _ in range(int(input())):
    print(sum(DP[int(input())-1])%1000000009)
```



## 쉬운계단수

> 45656이란 수를 보자.
> 이 수는 인접한 모든 자리수의 차이가 1이 난다. 이런 수를 계단 수라고 한다.
> N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구하는 프로그램을 작성하시오. (0으로 시작하는 수는 없다.)
>
> - 2 // 1~100의 자연수
> - 17 // 개수를 1,000,000,000으로 나눈 나머지

답안

```
num = [[0 for _ in range(10)] for _ in range(100)]

for i in range(1, 101):
	for j in range(10):
		if i == 1:
			num[i][j] = 1
		else:
			if 1 <= i <= 8:
				num[i][j] = num[i-1][j-1] + num[i-1][j+1]
			elif i == 0:
				num[i][j] = num[i-1][j+1]
			elif i == 9:
				num[i][j] = num[i-1][j-11]
n = int(input())
print(sum(num[N][1:10]) % 1000000000)
```

