#      다이나믹-1

- [1로 만들기](#1로-만들기)
- [2n 타일링](#2n-타일링)
- [2n 타일링2](#2n-타일링2)
- [1,2,3 더하기](#1,2,3-더하기)
- [카드구매하기](#카드구매하기)
- [1,2,3 더하기5](#1,2,3-더하기)
- [쉬운계단수](#쉬운계단수)
- [이친수](#이친수)
- [연속합](#연속합)
- [lis-1](#lis-1)
- [lis-4](#lis-4)
- [제곱수의 합](#제곱수의-합)
- [합분해](#합분해)
- [RGB거리](#RGB거리)
- [동물원](#동물원)
- [오르막수](#오르막수)
- [스티커](#스티커)
- [포도주시식](#포도주시식)

- [정수삼각형](#정수삼각형)
- [가장큰증가부분수열](#가장큰증가부분수열)



## 1로 만들기

> 1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
> 2. X가 2로 나누어 떨어지면, 2로 나눈다.
> 3. 1을 뺀다.
>
> - 입력: 10
> - 출력: 3
>
> 1로 만들기 위한, 연산의 최소 횟수를 출력

10 -> 9 -> 3 -> 1 로 세번의 연산을 거친다. 

재귀함수를 써서, 주어진 10부터 계산하는 것이 아니라, 처음 1, 2 여기서 부터 시작한다. 
이걸 bottom-up 방식이라고 하더라..

처음 밑바닥부터, 최적의 경로를 찾아가는 방식으로 풀어야함.

만약, 10 이 주어지면, **1,2가 나올때까지** 2와 3으로 나눔.
그리고 거기서부터 나머지를 더해가면서, 최솟값을 찾아나가는 방식

답안

```python
def f(n):
    if n <= 2: return n-1
    return 1 + min(f(n//3)+n%3, f(n//2)+n%2)
print(f(int(input())))
```

람다로 더 깔끔하게 

```python
f=lambda n:n-1 if n<3 else 1+min(f(n//2)+n%2,f(n//3)+n%3)
print(f(int(input())))
```



## 2n 타일링

> - n이 주어졌을때, 2 * n의 직사각형을 1 * 2, 2 * 1로 채우는 방법의 수를 출력
> - 9 => 55
>
> 출력값 =  방법수%10007

1 = 1
2 = 2
3 = 3
4 = 5
5 = 8

쭉 - 나열하다보면 f(n) = f(n-1) + f(n-2)의 합이라는 규칙이 보임.
이걸 간단한 재귀식인 a, b = b, a+b 으로 나타낼 수 있음. 

이걸 n번 반복하면 됨.

답안

```python
a,b = 1,1
for i in range(int(input())): a,b = b,a+b
print(a%10007) 
```



## 2n 타일링2

> 2*2타일도 넣을 수 있을때, 2\*n의 직사각형을 채우는 방법수.

1=1
2=3
3=5
4=11
5=21
...
규칙이 f(n) = f(n-1)+2*f(n-2) 이다. 

```python
def f(n):
    if n == 1: return 1
    elif n == 2: return 3
    else: return f(n-1)+2*f(n-2)

print(f(int(input()))%10007)
```

이렇게 풀면, 1000이전까지만 가능하다. 
왜냐하면 파이썬은 재귀를 1000으로 제한 하거든.

그래서 이전 타일링 문제처럼 반복문으로 만들어야함.

답안

```python
a,b=1,3
for _ in range(int(input())-1):
    a, b = b, 2*a+b
print(a%10007)
```

이 방법은 이전 재귀처럼 top-down이 아니라, bottom-up이기 때문에 더 좋다고 볼 수 있다. 

이전 방법은 100이 주어지면, 99랑 98을 찾고.. 했는데.
이번 방법은 100이 주어지면, 1부터 올라감. 
다이나믹은 항상 bottom-up이 옳다!



## 1,2,3 더하기

> 1,2,3의 합으로 만들 수 있는 경우의 수를 출력
> 조합의 순서가 달라도 다른 것으로 인정. ex) 1+2, 2+1

1=1
2=2
3=4
4=7
5=13
6=24
...
f(n) = f(n-1)+f(n-2)+f(n-3)

답안

```python
N = int(input())
def f(n):
    if n == 1: return 1
    elif n == 2: return 2
    elif n == 3: return 4
    else: return f(n-1)+f(n-2)+f(n-3)

for _ in range(N): print(f(int(input())))
```

bottom-up으로 하면..

```python
N = int(input())
for _ in range(N):
    a, b, c = 0, 0, 1
    for _ in range(int(input())): a, b, c = b, c, a+b+c
    print(c)
```

미리 만들어서 더 빨리 풀 수도 있다. 

```python
# 문제 = 1,2,3더하기3

d = [0, 1, 2, 4]
for i in range(4, 1000001):
    d.append((d[i-1]+d[i-2]+d[i-3])%1000000009)

N = int(input())
for _ in range(N):
    print(d[int(input())])
```



### 연속된 조합을 인정하지 않는 경우

> - 3 // 케이스 개수
>   4
>   7
>   10
> - 3
>   9
>   27
>
> 1,2,3의 합으로 나타냄. 같은 숫자가 두 번 이상 연속 올 수 없음.
> 방법의 수를 1000000009로 나눈 값을 출력

1,2,3 각 숫자로 시작하는 조합의 수

n의 1로 시작하는 조합은 n-1에서 1로 시작하는 조합을 제외한 조합들의 합
n의 2로 시작하는 조합은 n-2에서 2로 시작하는 조합을 제외한 조합들의 합 
n의 3로 시작하는 조합은 n-3에서 3로 시작하는 조합을 제외한 조합들의 합 

이전 값을 참고하기에 리스트에 저장을 해야하고, 다이나믹으로 풀어야한다.

DP[0] = [0, 0, 0]
DP[1] = [1, 0, 0] // (1)
DP[2] = [0, 1, 0] // (2)
DP[3] = [1, 1, 1] // (1+2) | (2+1) | (3)
DP[4] = [2, 0, 1] // (1+2+1),(1+3) | (3,1)
DP[5] = [1, 2, 1] // (1+3+1) | (2+1+2),(2+3) | (3,2)
DP[6] = [3, 3, 2]...

답안

```python
DP = [[0]*3 for _ in range(100001)]
DP[0] = [1,0,0]
DP[1] = [0,1,0]
DP[2] = [1,1,1]

for i in range(3,100001):
    DP[i][0] = (DP[i-1][1] + DP[i-1][2])%1000000009
    DP[i][1] = (DP[i-2][0] + DP[i-2][2])%1000000009
    DP[i][2] = (DP[i-3][0] + DP[i-3][1])%1000000009

for _ in range(int(input())):
    print(sum(DP[int(input())-1])%1000000009)
```



## 카드구매하기

> 주어진 숫자만큼의 카드를 가장 비싸게 구매할때의 가격
>
> - 4
>   1 5 6 7 
>   1장든 팩은 1원, 2장 팩은 5원, 2장은 6원....
> - 10 
>   4장의 카드를 가장 비싸게 사는 방법은 2팩을 2개 사서 10원에 사는 것. 10을 출력

카드 1개를 사는 가장 비싼 값(최고가)부터 해서..  2, 3개.. 의 최고가를 구해서 리스트에 추가. 
그렇게 n개의 방법을 구하는 bottom-up방식.

리스트에 1개를 사는 최고가부터 넣어두고, 
n개의 최고가를 알기 위해서 

- 1개의 최고가에 n-1개 팩의 가격을 더한 값 
- 2개의 최고가에 n-2개 팩의 가격을 더한 값
- ...
- n개 팩의 값

이중에서 가장 큰 값을 리스트에 더하는 하는 방식.
이걸 n까지 하면, 마지막 리스트값이 n개를 가장 비싸게 살때의 값이 됨.
min으로 하면 반대로 가장 싸게 사는 방법.

답안

```python
n = int(input())
price = list(map(int, input().split()))

ans = [0]
for i in range(1,n+1):
    ans.append(max(ans[i-j-1] + price[j] for j in range(i)))
print(ans[-1])
```



## 쉬운계단수

> 45656이란 수를 보자.
> 이 수는 인접한 모든 자리수의 차이가 1이 난다. 이런 수를 계단 수라고 한다.
> N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구하는 프로그램을 작성하시오. (0으로 시작하는 수는 없다.)
>
> - 2 // 1~100의 자연수
> - 17 // 개수를 1,000,000,000으로 나눈 나머지

끝자리 0~9의 각 자리에서의 방법수를 기록하는 리스트를 만든다. 
n이 주어질때, 각 끝자리에 대한 방법의 수는 n-1에서 해당 자리수 양옆의 자리수에 대한 방법수의 합이다. 
단, 0, 9에서는 한 쪽만 가져온다.

이렇듯, 문제에서 어떤 값이 앞선 값과 관계가 있을때는 각 자리수와 같은 **부분으로 나눠서 점화식**을 세워보는 것이 중요.

답안

```python
num = [[0 for _ in range(10)] for _ in range(100)]

for i in range(1, 101):
	for j in range(10):
		if i == 1:
			num[i][j] = 1
		else:
			if 1 <= i <= 8:
				num[i][j] = num[i-1][j-1] + num[i-1][j+1]
			elif i == 0:
				num[i][j] = num[i-1][j+1]
			elif i == 9:
				num[i][j] = num[i-1][j-1]
n = int(input())
print(sum(num[n][1:10]) % 1000000000)
```



## 이친수

> 0과 1로만 이루어진 수를 이진수라 한다. 이러한 이진수 중 특별한 성질을 갖는 것들이 있는데, 이들을 이친수(pinary number)라 한다. 이친수는 다음의 성질을 만족한다.
>
> 1. 이친수는 0으로 시작하지 않는다.
> 2. 이친수에서는 1이 두 번 연속으로 나타나지 않는다. 즉, 11을 부분 문자열로 갖지 않는다.
>
> 예를 들면 1, 10, 100, 101, 1000, 1001 등이 이친수가 된다. 하지만 0010101이나 101101은 각각 1, 2번 규칙에 위배되므로 이친수가 아니다.
>
> N(1 ≤ N ≤ 90)이 주어졌을 때, N자리 이친수의 개수를 구하는 프로그램을 작성하시오.
>
> - 3
> - 2 // 101, 100

3의 이친수를 구할 때는 3-1의 이친수의 끝자리를 보고, 
0이면 1과 0을 덧붙여서 두개를 더 만들 수 있고, 
1이면 0을 붙여서 하나를 만들 수 있다.

그러니까 이친수의 끝숫자인 0과 1의 개수만 알면 된다.
90개의 0과1의 개수를 기록하는 리스트를 만들고,

이전 값의 0개수만큼을 현재값의 0개수와 1개수에 더하고,
이전 값의 1개수만큼을 현재값의 0개수에 더한다.

답안

```python
d = [[0, 0] for _ in range(91)]
d[1] = [0, 1]
for i in range(2, 91):
    d[i][0] = d[i-1][0]+d[i-1][1]
    d[i][1] = d[i-1][0]

n = int(input())
print(sum(d[n]))
```



## 연속합

> n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다.
>
> 예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자. 여기서 정답은 12+21인 33이 정답이 된다.
>
> - 10
> - 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 // -1000<= x <=1000

중요한 것은 **연속한** 수열의 합이라는 것.

수열을 순회하면서 **i에서의 최댓값은 i-1까지의 최댓값에서 i값을 더한 값, i값중 더 큰 값이 된다.**

답안

```python
n = int(input())
num = list(map(int, input().split()))
d = [0 for _ in range(n)]

for i in range(n):
    d[i] = max(d[i-1] + num[i], num[i])

ans = max(d)
print(ans)
```



## 부분수열시리즈

### 가장긴증가하는부분수열

> 수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.
>
> 예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {**10**, **20**, 10, **30**, 20, **50**} 이고, 길이는 4이다.
>
> - 6
>   10 20 10 30 20 50
> - 4

일단, 받은 수열길이 만큼의 d=[0]*n을 만든다.

주어진 수열을 순회할 때, 각 요소의 왼쪽 편 요소들을 순회한다. 
이중루프로 돌면서, 
**자기보다 작은 숫자들의 d값 중 최댓값에서 1을 더한다.**

`num[i] > num[j]` 중에서 d의 최댓값을 구하는 방법은 `d[i] < d[j]` 를 만족하는 d[j]를 d[i]로 교체해 나가면 된다.

```python
n = int(input())
num = list(map(int, input().split()))
d = [0]*n

for i in range(n):
    for j in range(i):
        if num[i] > num[j] and d[i] < d[j]:
            d[i] = d[j]
    d[i] += 1

print(max(d)) 
```

위 방법은 n^2 복잡도를 가진다. 

d[i]을 구하기위해 num[0] ~ num[i-1]까지 다 훑어볼 필요가 있을까?

알아야하는 것은 수열을 순회하며, 왼쪽에서 나보다 작은 값, 그리고 그 그 값들 중에서 부분수열의 길이가 가장 긴 값이다.
위의 방법처럼 현재수열의 값에 1:1로 대응되도록 만들어도 쓰이는 값은 나보다 작은 값에서 길이의 '최댓값' 이기에, 
최댓값을 인덱스key로 그때의 끝값을 value로 저장하는 방식으로 더 효율적인 계산이 가능하다. 

- [참고자료](https://namu.wiki/w/최장 증가 부분 수열)  

```python
# sum([]) => 0
# sum([True, True, False]) => 2 
```

답안

```python
input()
num = list(map(int, input().split()))
d = {}

for x in num:
    d[sum(x > d[i] for i in d)] = x
print(len(d))
```

가장긴감소하는부분수열

```python
input()
num = map(int, input().split())
d = {}

for x in num:
    d[sum(d[i]>x for i in d)] = x
print(len(d))
```



### 가장긴증가하는부분수열4

> 앞선 문제가 '가장 긴 증가하는 부분수열의' **길이**를 출력하는 문제였다면, 
> 이번 문제는 LIS, 수열을 출력하는 문제이다. 
>
> - 6
>   10 20 10 30 20 50
> - 4
>   10 20 30 50

앞에서 만든 알고리즘은 길이만 알 수 있지 수열 자체를 저장하지는 못한다.
수열까지 저장하기 위해서는 lis-1에서 처음쓴 이중 for문 방법이 필요함.

주어진 수열 A를 순회하면서 A[i] 에서 A[1] ~ A[i-1]를 검사. (이중 for문)
A[i] 보다 작은 A[j]에서 d가 가장 클 때의 j인덱스를 구함.

이걸 lis-1에서 처럼 try-catch, max가 아닌, if로 해결하는데 훨씬 깔끔함.

최장수열의 길이를 저장하는 d[i] 리스트에서 추가로, **res[i]리스트를 만들어서, 최장수열 '수열' 자체를 저장**함.
res[i] 는 A[i]로 끝나는 최대증가부분수열.

```python
# ex
>>> 6
>>> 1 2 1 3 2 5

# print(res)
[[1], [1, 2], [1], [1, 2, 3], [1, 2], [1, 2, 3, 5]]
# print(d)
[1, 2, 1, 3, 2, 4]
```

그럼, res리스트에서 최장 길이를 가진 리스트가 답이 됨.

답안

```python
n = int(input())
num = list(map(int, input().split()))
d = [0]*n
res = [[x] for x in num]

for i in range(n):
    for j in range(i):
        if num[i] > num[j] and d[i] < d[j]:
            d[i] = d[j]
            res[i] = res[j] + [num[i]]
    d[i] += 1
ans = max(d)
print(ans)
print(*res[d.index(ans)])
```



### 가장큰증가부분수열

수열 A가 주어졌을 때, 그 수열의 증가 부분 수열 중에서 합이 가장 큰 것을 구하는 프로그램을 작성하시오.

예를 들어, 수열 A = {1, 100, 2, 50, 60, 3, 5, 6, 7, 8} 인 경우에 합이 가장 큰 증가 부분 수열은 A = {**1**, 100, **2**, **50**, **60**, 3, 5, 6, 7, 8} 이고, 합은 113이다.

```
10
1 100 2 50 60 3 5 6 7 8

첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.
둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)
```

```
113 

첫째 줄에 수열 A의 합이 가장 큰 증가 부분 수열의 합을 출력한다.
```

***

단순하게 생각하면, 

주어진 수열을 순회하면서 왼쪽에 자기보다 작은 숫자들을 찾고, 
그 작은 숫자들을 끝으로 하는 최대합 수열을 따로 리스트로 정리하는 것.

말로하면 좀 이해가 안되는데, 그냥 **왼쪽에서 자기보다 작은 수 중에서 합이 젤 큰 수의 합에 자기를 더하면 된다.**

| 주어진 수열              | 2     | 1     | 5     | 6      | 7      |
| ------------------------ | ----- | ----- | ----- | ------ | ------ |
| **가장 큰 증가부분수열** | **2** | **1** | **7** | **13** | **20** |

```python
n = int(input())
num = list(map(int, input().split()))

a = num.copy()

for i in range(n):
    idx = [j for j in range(i) if num[j]<num[i]]
    if len(idx)!=0: a[i] += max([a[i] for i in idx])
print(max(a))
```

답을 구하기 위해 필요한 값은, 수열에서 **왼쪽에 있는 자기보다 작은 값의 인덱스+ 그때의 합의 최대값** 이다.

애초에 d=[0]*1001으로 정의해서 인덱스를 수열의 값에 일치시키고, 그 인덱스의 값으로는 최대합을 넣으면 위에서 처럼 따로 인덱스 리스트를 만들 필요가 없다.

```python
input()
num = map(int,input().split())
d = [0]*1001

for x in num:
	d[x] = max(d[:x]) + x
print(max(d))
```



### 가장긴바이토닉부분수열

> 수열 S가 어떤 수 Sk를 기준으로 S1 < S2 < ... Sk-1 < Sk > Sk+1 > ... SN-1 > SN을 만족한다면, 그 수열을 바이토닉 수열이라고 한다.
>
> 예를 들어, {10, 20, **30**, 25, 20}과 {10, 20, 30, **40**}, {**50**, 40, 25, 10} 은 바이토닉 수열이지만,  {1, 2, 3, 2, 1, 2, 3, 2, 1}과 {10, 20, 30, 40, 20, 30} 은 바이토닉 수열이 아니다.
>
> 수열 A가 주어졌을 때, 그 수열의 부분 수열 중 바이토닉 수열이면서 가장 긴 수열의 길이를 구하는 프로그램을 작성하시오.

- ```
  10
  1 5 2 1 4 3 4 5 2 1
  
  첫째 줄에 수열 A의 크기 N이 주어지고, 둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ N ≤ 1,000, 1 ≤ Ai ≤ 1,000)
  ```

  예제의 경우 {**1** 5 **2** 1 4 **3** **4** **5** **2** **1**}이 가장 긴 바이토닉 부분 수열이다.

- ```
  7
  
  첫째 줄에 수열 A의 부분 수열 중에서 가장 긴 바이토닉 수열의 길이를 출력한다.
  ```

***

zip내장함수 = [설명](https://medium.com/@hckcksrl/python-zip-내장함수-95ad2997990)

가장 긴 부분증가수열에서 응용하여, 왼쪽과 오른쪽을 다 살펴서 정리하는 방법을 쓴다. 

하... 너무 어렵다. 다른분 답을 봐도 잘 이해가 안된다. 

```python
input();
d = {}
e = {}
a = []
num = list(map(int,input().split()))
r = 0
for i in num:
    s = sum(i>d[k] for k in d)
    d[s] = i
    a[:0] = s,
for i,a in zip(num[::-1], a):
    s = sum(i > e[k] for k in e)
    e[s] = i
    r = max(r,a+s+1)
print(r)
```



## 제곱수의 합

> 어떤 자연수 N은 그보다 작거나 같은 제곱수들의 합으로 나타낼 수 있다. 예를 들어 11=3^2+1^2+1^2(3개 항)이다. 이런 표현방법은 여러 가지가 될 수 있는데, 11의 경우 11=2^2+2^2+1^2+1^2+1^2(5개 항)도 가능하다. 이 경우, 11은 그보다 적은 항의 제곱수 합으로 표현할 수 없으므로, 11을 그 합으로써 표현할 수 있는 제곱수 항의 최소 개수는 3이다.
>
> 주어진 자연수 N을 이렇게 제곱수들의 합으로 표현할 때에 그 항의 최소개수를 구하는 프로그램을 작성하시오.
>
> - 7 // 100,000이하
> - 4 // 1의 제곱 3개, 2의 제곱하나 해서 4

1~10000**0.5까지의 숫자를 제곱한 값의 리스트를 만든다.
받은 숫자에 리스트 숫자를 하나씩 빼본다. 

이때, 뺀 값이 0보다 작을 경우의 이전 리스트값을 받은 숫자에서 뺀다. 
이걸 숫자가 0이 될때까지 반복한다.

라고 생각했다...

```python
n = int(input())
num = [i**2 for i in range(1, 318)]
c = 0
while n:
    for i in range(317):
        if n - num[i] < 0:
            n = n - num[i-1]
            c += 1
            break
print(c)
```

 맞다고 생각했는데, 이게 아니었다. 

예를 들어 32를 넣으면 위 알고리즘으로는 5가 나온다. 25+4+1+1+1
하지만 답은 2다. 16+16

그러니까, 무작정 큰 제곱수를 빼는 것이 답이 아니었다. 

예를 들어 **12에서 쓸 수 있는 제곱수는 1, 4, 9 이다. 그럼, 12의 제곱합은 12를 1, 4, 9로 뺀 값들의 제곱합 중에서 최솟값+1이다.**

```python
d[12] = min(d[12-1], d[12-4], d[12-9]) + 1
```

답안

```python
n = int(input())
d = [0]*(n+1)
for i in range(1, n+1):
    d[i] = min([d[i-j**2]+1 for j in range(1,int(i**0.5)+1)])
print(d[-1])
```



## 합분해

> 0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 프로그램을 작성하시오.
>
> 덧셈의 순서가 바뀐 경우는 다른 경우로 센다(1+2와 2+1은 서로 다른 경우). 또한 한 개의 수를 여러 번 쓸 수도 있다.
>
> - 20 2 // 첫째 줄에 두 정수 N(1 ≤ N ≤ 200), K(1 ≤ K ≤ 200)가 주어진다.
> - 21 // 첫째 줄에 답을 1,000,000,000으로 나눈 나머지를 출력한다.

n 2 의 경우의 수는 n+1이다. 

> 아래 방법은 진짜 삽질 그 자체니 그냥 넘어가도록 하자.

N이 10일때, K값에 따른 경우의 수, K가

1개의 경우의 수 1개
2개의 경우의 수 11개
3개의 경우의 수 11+10+9+ ... + 1
4개의 경우의 수 11\*1+10\*2 + 9\*3 + 8\*4... + 2\*10 + 1\*11
5개의 경우의 수 11\*1 + 10\*(1+2) + 9\*(1+2+3) + 8\*(1+2+3+4) + ... + 1*(1+2+ ... +11)

f(N, K)라고 할때, 
f(10, 0) = 0
f(10, 1) = 1
f(10, 2) = 11
f(10, 3) = 1\*f(10, 1) + 2*f(9, 1) + 3\*f(8, 1) + ... + 10\*f(1, 1) + 11\*f(0, 1)
f(10, 4) = 1\*f(10, 2) + 2\*f(9, 2) + 3\*f(8, 3) + ... + 10\*f(1, 3) + 11\*f(0, 3)

**f(N, K) = 1\*f(N, K-2) + 2\*f(N-1, K-2) + 3*f(N-2, K-2) + ... + N\*f(1, K-2) + (N+1)\*f(0, K-2)**

```python
N, K = map(int, input().split())

def f(n, k):
    if k == 1: return 1
    if k == 2: return n+1
    return sum([i*f(n+1-i, k-2) for i in range(1, n+2)])%1000000000

print(f(N, K))
```

위 알고리즘은 시간초과가 난다.

검색해보니, 2차원 DP로 푸는 방법이 있다. 
https://br-brg.tistory.com/18

N, K 두개의 값을 받으니까, 두 값을 축으로 그려보자.

| k\n   | **0** | **1** | **2** | **3** | **4** |
| ----- | ----- | ----- | ----- | ----- | ----- |
| **1** | 1     | 1     | 1     | 1     | 1     |
| **2** | 1     | 2     | 3     | 4     | 5     |
| **3** | 1     | 3     | 6     | 10    | 15    |

```python
f(n, k) = f(n-1, k) + f(n, k-1)
```

쉽게 점화식이 구해진다. 

이걸 인덱스를 조심하면서 구현하면 된다. 

```python
n, k = map(int, input().split())
d = [[1]*(n+1) for _ in range(k)]

for i in range(1, k):
    for j in range(1, n+1):
        d[i][j] = (d[i-1][j] + d[i][j-1])%1000000000

print(d[k-1][n])
```

변수가 두 개니까 2차원적으로 생각을 해야한다는 교훈..



## RGB거리

> RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.
>
> 집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.
>
> - 1번 집의 색은 2번 집의 색과 같지 않아야 한다.
> - N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.
> - i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.
>
> 
>
> - 3
>   1 2 3
>   1 2 3
>   100 1 100
> - 4

1번 집이 R, G, B 일때를 모두 검사해야한다. 
1번이 R일때, 2번은 G, B 중 작은 값을 선택한다. 

그래서 1번 집의 3가지 페인트 비용으로 리스트를 만들고, 이후로 2, 3.. 페인트 값을 받아서 가능한 작은 값을 해당 리스트에 더해가는 방식으로 만들었음.
근데 틀렸다. 왜 틀린지는 잘 모르겠다..

```python
# 틀린답.
n = int(input())

p = list(map(int, input().split()))
index = [0, 1, 2]
for _ in range(n-1):
    num = list(map(int, input().split()))
    for i in range(3):
        m = 1001
            c = 0
        for j in range(3):
            if j != index[i] and m > num[j]:
                m = num[j]
                c = j
        index[i] = c
        p[i] += num[c]
print(min(p))
```

난 시간아낀다고, 한 줄 받을때마다 업데이트하는 방식으로 했는데, 그럴 필요가 없었다. 
전체를 리스트로 받아서, 훨씬 쉽게 만들 수 있었다. 

이전 값에서 인덱스가 다른 값 중, 작은 값을 현재값을 더해간다.
그걸 처음부터 끝까지 쭉 - 하면 된다. 

1번집이 R, G, B일때 3개 중에서 가장 작은 값이 답이다. 

답안

```python
n = int(input())
p = []
for _ in range(n):
    p.append(list(map(int, input().split())))
for i in range(1, n):
    p[i][0] += min(p[i-1][1], p[i-1][2]) 
    p[i][1] += min(p[i-1][0], p[i-1][2]) 
    p[i][2] += min(p[i-1][0], p[i-1][1])

print(min(p[-1][0], p[-1][1], p[-1][2])) 
```

쉽게 생각하면 이렇게 시간을 많이 쓰진 않았을 것인데.. 안타깝다.



## 동물원

> 어떤 동물원에 가로로 두칸 세로로 N칸인 아래와 같은 우리가 있다.
> 이 동물원에는 사자들이 살고 있는데 사자들을 우리에 가둘 때, 가로로도 세로로도 붙어 있게 배치할 수는 없다. 이 동물원 조련사는 사자들의 배치 문제 때문에 골머리를 앓고 있다.
>
> 동물원 조련사의 머리가 아프지 않도록 우리가 2*N 배열에 사자를 배치하는 경우의 수가 몇 가지인지를 알아내는 프로그램을 작성해 주도록 하자. 사자를 한 마리도 배치하지 않는 경우도 하나의 경우의 수로 친다고 가정한다.
>
> - 4 // 첫째 줄에 우리의 크기 N(1≤N≤100,000)이 주어진다.
> - 41 // 첫째 줄에 사자를 배치하는 경우의 수를 9901로 나눈 나머지를 출력하여라.

하.. 이 문제..
점화식을 왜 발견하지 못했을까..

- f(1) = 3
- f(2) = 7
- f(3) = 17
- f(4) = 41

점화식은 `f(n) = 2*f(n-1) + f(n-2)` 이다. 
100,1000까지 이기에, 

```python
def f(n):
	return 2*f(n-1)+f(n-2)
# 1000 재귀제한에 걸린다.
```

답안

```python
d = [0, 3, 7]
for i in range(3, 100001):
    d.append((2*d[-1]+d[-2])%9901)
print(d[int(input())])
```



## 오르막수

> 오르막 수는 수의 자리가 오름차순을 이루는 수를 말한다. 이때, 인접한 수가 같아도 오름차순으로 친다.
> 예를 들어, 2234와 3678, 11119는 오르막 수이지만, 2232, 3676, 91111은 오르막 수가 아니다.
> 수의 길이 N이 주어졌을 때, 오르막 수의 개수를 구하는 프로그램을 작성하시오. 수는 **0으로 시작할 수 있다.**
>
> - 2 // 첫째 줄에 N (1 ≤ N ≤ 1,000)이 주어진다.
> - 55 // 첫째 줄에 길이가 N인 오르막 수의 개수를 10,007로 나눈 나머지를 출력한다.

이것도 간단한건데.. 난 계속 어렵게 풀려고 하다가 시간만 날리고.. 후..

|           | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |
| --------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| **n = 1** | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| **n = 2** | 1    | 3    | 6    | 10   | 15   | 21   | 28   | 36   | 45   | 55   |

2차원으로 보면 d\[i][j] = sum(d\[i-1][0~9]) 인 것을 알 수 있다.

답안

```python
d =  [[1] * 10 for i in range(1001)]

for i in range(1, 1001):
    for j in range(1, 10):
        d[i][j] = (d[i-1][j] + d[i][j-1])%10007
print(d[int(input())][-1])
```

이 문제를 풀면서 새로운 사실을 알아냈다. 

```python
>>> a = [[0]*3]*3
>>> a[1][1]=1
>>> a
[[0, 1, 0], [0, 1, 0], [0, 1, 0]]
# 다른 부분도 다 바뀐다. 

>>> a = [[0]*3 for _ in range(3)]
>>> a[1][1]=1
>>> a
[[0, 0, 0], [0, 1, 0], [0, 0, 0]]
# 지정한 부분만 바뀐다.
```

*는 얕은 복사라서 nested한 애들은 복사가 안된다. 이게 틀린지 모르고 몇시간을 삽질했나 모르겠다..

[스택오버플로 설명](https://stackoverflow.com/questions/29306418/python-operator-creating-list-with-default-value) 



## 스티커

상근이의 여동생 상냥이는 문방구에서 스티커 2n개를 구매했다. 스티커는 그림 (a)와 같이 2행 n열로 배치되어 있다. 상냥이는 스티커를 이용해 책상을 꾸미려고 한다.

상냥이가 구매한 스티커의 품질은 매우 좋지 않다. 스티커 한 장을 떼면, 그 스티커와 변을 공유하는 스티커는 모두 찢어져서 사용할 수 없게 된다. 즉, 뗀 스티커의 왼쪽, 오른쪽, 위, 아래에 있는 스티커는 사용할 수 없게 된다.

모든 스티커를 붙일 수 없게된 상냥이는 각 스티커에 점수를 매기고, 점수의 합이 최대가 되게 스티커를 떼어내려고 한다. 상냥이가 뗄 수 있는 스티커의 점수의 최댓값을 구하는 프로그램을 작성하시오. 즉, 2n개의 스티커 중에서 점수의 합이 최대가 되면서 서로 변을 공유 하지 않는 스티커 집합을 구해야 한다.

- ```
  2
  5
  50 10 100 20 40
  30 50 70 10 60
  7
  10 30 10 50 100 20 40
  20 40 30 50 60 20 80
  
  # 첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 n (1 ≤ n ≤ 100,000)이 주어진다. 다음 두 줄에는 n개의 정수가 주어지며, 각 정수는 그 위치에 해당하는 스티커의 점수이다. 연속하는 두 정수 사이에는 빈 칸이 하나 있다. 점수는 0보다 크거나 같고, 100보다 작거나 같은 정수이다. 
  ```

- ```
  260
  290
  
  # 각 테스트 케이스 마다, 2n개의 스티커 중에서 두 변을 공유하지 않는 스티커 점수의 최댓값을 출력한다.
  ```

최대가 되도록 선택을 하는 문제.
비슷한 문제를 많이 풀었는데도 왤케 헤매는 거니..

점화식은 아래와 같다. 

```python
d[0][i] += max(d[1][i-1], d[1][i-2])
d[1][i] += max(d[0][i-1], d[0][i-2])
```

```python
d[0][0~1]
d[1][0~1]
초기값을 설정해준뒤, 위의 식을 돌린다. 

max(d[0][-1], d[1][-1])
마지막에 오는 두개의 값 중 더 큰 값이 답이다. 
```

답안

```python
for _ in range(int(input())):
    n = int(input())
    num = []
    for _ in range(2):
        num.append(list(map(int, input().split())))
    num[0][1] += num[1][0]
    num[1][1] += num[0][0]
    for i in range(2, n):
        num[0][i] += max(num[1][i-1], num[1][i-2])
        num[1][i] += max(num[0][i-1], num[0][i-2])
    print(max(num[0][-1], num[1][-1]))
```

시작 위치에 따라 두가지가 나온다는 것은 알고 있었지만, 그 이후 최댓값을 위한 알고리즘을 만드는 것에서 고전을 했다.
많은 부분을 참고하지 않아도 된다는 것을 알아야한다. 
선택에 영향을 주는 범위를 파악하고, 그 부분의 점화식을 만들면 끝이다.

언제나 답은 간단하다. 나의 생각만 쓸데없이 복잡할 뿐..



## 포도주시식

효주는 포도주 시식회에 갔다. 그 곳에 갔더니, 테이블 위에 다양한 포도주가 들어있는 포도주 잔이 일렬로 놓여 있었다. 효주는 포도주 시식을 하려고 하는데, 여기에는 다음과 같은 두 가지 규칙이 있다.

1. 포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다.
2. 연속으로 놓여 있는 3잔을 모두 마실 수는 없다.

효주는 될 수 있는 대로 많은 양의 포도주를 맛보기 위해서 어떤 포도주 잔을 선택해야 할지 고민하고 있다. 1부터 n까지의 번호가 붙어 있는 n개의 포도주 잔이 순서대로 테이블 위에 놓여 있고, 각 포도주 잔에 들어있는 포도주의 양이 주어졌을 때, 효주를 도와 가장 많은 양의 포도주를 마실 수 있도록 하는 프로그램을 작성하시오. 

예를 들어 6개의 포도주 잔이 있고, 각각의 잔에 순서대로 6, 10, 13, 9, 8, 1 만큼의 포도주가 들어 있을 때, 첫 번째, 두 번째, 네 번째, 다섯 번째 포도주 잔을 선택하면 총 포도주 양이 33으로 최대로 마실 수 있다.

```
첫째 줄에 포도주 잔의 개수 n이 주어진다. (1≤n≤10,000) 둘째 줄부터 n+1번째 줄까지 포도주 잔에 들어있는 포도주의 양이 순서대로 주어진다. 포도주의 양은 1,000 이하의 음이 아닌 정수이다.

6
6
10
13
9
8
1
```

```
첫째 줄에 최대로 마실 수 있는 포도주의 양을 출력한다.

33
```

숫자를 받아서 리스트 num에 저장, 
리스트 d에 해당 인덱스까지의 최댓값을 더해가는 방식으로 구한다.

```python
num = [int(input()) for _ in range(int(input()))]
d = []
```

d[i]를 결정하기위한 케이스는 3가지다. 

- 이전 포도주를 마시고, 이번 포도주도 마실때
- 이전 포도주는 안마지시고, 이번 포도주를 마실때
- 어번에 포도주를 못마실 때

| i-2  | i-1  | i    |
| ---- | ---- | ---- |
| o    | x    | o    |
| x    | o    | o    |
| o    | o    | x    |

답안

```python
n = int(input())
num = [int(input()) for _ in range(n)]
d = [0]
d.append(num[0])
if n > 1: d.append(num[0]+num[1])

for i in range(3, n+1):
    a = num[i-1] + d[i-2]
    b = num[i-1] + num[i-2] + d[i-3]
    c = d[i-1]
    d.append(max(a,b,c))
print(d[n])
```

현재위치포함 뒤에 2개만 알면 되니까, 더 쉽게 만들 수도 있다. 

답안

```python
d = (0,)*3
for _ in range(int(input())):
    p = int(input())
    d = d[1]+p, d[2]+p, max(d)
    print(d)
print(max(d))
```

아래와 같은 코드도 같은 일을 한다고 생각하기 쉽다. 
하지만, 위와 같이 한번에 바꾸지않으면, 바뀐 값을 참고하게 되면서 틀리게 된다.

```python
d = [0]*3
for _ in range(int(input())):
    p = int(input())
    d[0] = d[1] + p
    d[1] = d[2] + p
    d[2] = max(d)
print(max(d))
```

앞선 문제와 같은 최댓값을 구하는 문제. 3가지의 케이스가 있다. 
이런 문제는 어떤 선택의 케이스가 있는지를 파악하고, 그걸 점화식으로 만드는 것이 중요하다. 

위에 설명처럼 표를 그려봤다면 쉽게 이해할 수 있었을 텐데..  아쉽다.



## 정수삼각형

```
        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
```

위 그림은 크기가 5인 정수 삼각형의 한 모습이다.

맨 위층 7부터 시작해서 아래에 있는 수 중 하나를 선택하여 아래층으로 내려올 때, 이제까지 선택된 수의 합이 최대가 되는 경로를 구하는 프로그램을 작성하라. 아래층에 있는 수는 현재 층에서 선택된 수의 대각선 왼쪽 또는 대각선 오른쪽에 있는 것 중에서만 선택할 수 있다.

삼각형의 크기는 1 이상 500 이하이다. 삼각형을 이루고 있는 각 수는 모두 정수이며, 범위는 0 이상 9999 이하이다.

```
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5

첫째 줄에 삼각형의 크기 n(1 ≤ n ≤ 500)이 주어지고, 둘째 줄부터 n+1번째 줄까지 정수 삼각형이 주어진다.
```

```
30

첫째 줄에 합이 최대가 되는 경로에 있는 수의 합을 출력한다.
```

***

"포도주시식" 문제처럼 수열을 받아서, 최대가 되는 리스트로 업데이트를 해주는 방식으로 풀면 된다.

접근할때 중요한건 중간에 최댓값을 구해서 동적으로 푸는게 아니라, 최대가 될 '후보'들의 리스트를 만들어 나가는 것이다. 
전체 순회를 마치고 나서 리스트에서의 최댓값이 답이 된다. 

```python
n = int(input())

a = [int(input())]
for i in range(2, n+1):
    d = list(map(int, input().split()))
    for j in range(i):
        if j == 0: d[j] += a[0]
        elif j == i-1: d[j] += a[i-2]
        else: d[j] += max(a[j-1], a[j])
    a = d

print(max(a))
```



 