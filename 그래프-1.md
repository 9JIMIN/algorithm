# 그래프-1

그래프 알고리즘을 위해서 DFS와 BFS를 정확히 이해하고, 구현할 수 있어야 한다. 

[참고자료](https://covenant.tistory.com/132)



### DFS와 BFS

> [문제](https://www.acmicpc.net/problem/1260)

답안

```python
n, m, v = map(int, input().split())
matrix = [[0] * (n + 1) for _ in range(n + 1)]
for _ in range(m):
    line = list(map(int, input().split()))
    matrix[line[0]][line[1]] = 1
    matrix[line[1]][line[0]] = 1

def bfs(start):
    visited = [start]
    queue = [start]
    while queue:
        n = queue.pop(0)
        for c in range(len(matrix[start])):
            if matrix[n][c] == 1 and (c not in visited):
                visited.append(c)
                queue.append(c)
    return visited

def dfs(start, visited):
    visited += [start]
    for c in range(len(matrix[start])):
        if matrix[start][c] == 1 and (c not in visited):
            dfs(c, visited)
    return visited

print(*dfs(v,[]))
print(*bfs(v))
```



### ABCDE

[문제](https://www.acmicpc.net/problem/13023)

문제 이해가 잘 안될 수 있다. [여기를 참고](https://grini25.tistory.com/110)
간단하게 설명하면, 주어진 관계를 그래프로 그렸을때, 
노드를 중복해서 쓰지않고 이어서, 5개를 이을 수 있는지의 여부를 출력하는 문제이다.

DFS 알고리즘으로 풀 수 있다. 

n개의 노드가 주어지면, 모든 시작노드를 돌려본다.
방문한 노드는 False, 방문하지 않은 노드에 대해서는 재귀로 돌게 한다. 

재귀가 생길때마다 카운트를 늘려간다.
카운트가 목표한 4가 되면 1을 출력, 
모든 노드를 돌아도 없을때는 0을 출력한다.

답안

```python
n, m = map(int, input().split())
rel = [[] for _ in range(n)]
visited = [False for _ in range(n)]

for _ in range(m):
    a, b = map(int, input().split())
    rel[a].append(b)
    rel[b].append(a)

def dfs(count, node):
    visited[node] = True
    if count == 4:
        print(1)
        exit()
    for x in rel[node]:
        if not visited[x]:
            dfs(count+1, x)
            visited[x] = False

for i in range(n):
    dfs(0, i)
    visited[i] = False
print(0)
```

