# 그래프-1

그래프 알고리즘을 위해서 DFS와 BFS를 정확히 이해하고, 구현할 수 있어야 한다. 

[참고자료](https://covenant.tistory.com/132)



### DFS와 BFS

> [문제](https://www.acmicpc.net/problem/1260)
>
> 방문할 수 있는 정점이 여러개인 경우, 정점번호가 작은 것을 먼저 방문해야 함에 유의!

DFS, BFS의 기본적인 구현.
알면 쉽지만, 모르면 풀 수 없는 문제.

- BFS는 되돌아 오지 않는다. 
  연결된 모든 노드를 더해나가는 방식임.
- DFS는 하나하나 따라가보는 방식이다.
  끝에 도달하면, 끝난다.

이문제는 시작노드가 정해져 있어서, 한 시작노드만 탐색하면 된다. 방문노드를 초기화할 필요가 없다.
추후, ABCDE 문제의 경우 모든 노드를 시작으로 돌려봐야하기에, 방문노드를 초기화하는 과정이 필요하다.  

답안

```python
n, m, v = map(int, input().split())
rel = [[] for _ in range(n+1)] # 노드를 1,2,3.. 이렇게 하기 때문에 0번은 비워줌.
visited = []

for _ in range(m):
    a, b = map(int, input().split())
    rel[a].append(b)
    rel[b].append(a)

def bfs(x):
    visited.append(x)
    for a in visited:
        for b in sorted(rel[a]):
            if b not in visited:
                visited.append(b)
    return visited

def dfs(x):
    visited.append(x)
    for a in sorted(rel[x]):
        if a not in visited:
            dfs(a)
    return visited

print(*dfs(v))
visited = []
print(*bfs(v))
```



### ABCDE

[문제](https://www.acmicpc.net/problem/13023)

문제 이해가 잘 안될 수 있다. [여기를 참고](https://grini25.tistory.com/110)
간단하게 설명하면, 주어진 관계를 그래프로 그렸을때, 
노드를 중복하지 않고 이어서, 5개를 이을 수 있는지의 여부를 출력하는 문제이다.

모든 경우를 살펴야 하기에 DFS 알고리즘으로 풀 수 있다. 

n개의 노드가 주어지면, 모든 노드를 시작노드를 돌려보고, 연결이 4번이 되면 1을 출력, 안되면, 0을 출력한다.
방문한 노드는 True를 표시하고, 방문하지 않은 노드에 대해서는 재귀로 돌게 한다. 

**모든 노드를 확인해야하기에, 되돌아올때는 지나온 경로의 visited를 다시 False로 바꿔줘야한다.**

재귀가 생길때마다 카운트를 늘려간다.
카운트가 목표한 4가 되면 1을 출력, 
모든 노드를 돌아도 없을때는 0을 출력한다.

답안

```python
n, m = map(int, input().split())
rel = [[] for _ in range(n)]
visited = [False for _ in range(n)]

for _ in range(m):
    a, b = map(int, input().split())
    rel[a].append(b)
    rel[b].append(a)

def dfs(count, node):
    visited[node] = True
    if count == 4:
        print(1)
        exit()
    for x in rel[node]:
        if not visited[x]:
            dfs(count+1, x)
            visited[x] = False

for i in range(n):
    dfs(0, i)
    visited[i] = False
print(0)
```

