# 그래프-1

그래프 알고리즘을 위해서 DFS와 BFS를 정확히 이해하고, 구현할 수 있어야 한다. 

[참고자료](https://covenant.tistory.com/132)



### DFS와 BFS

> [문제](https://www.acmicpc.net/problem/1260)
>
> 방문할 수 있는 정점이 여러개인 경우, 정점번호가 작은 것을 먼저 방문해야 함에 유의!

DFS, BFS의 기본적인 구현.
알면 쉽지만, 모르면 풀 수 없는 문제.

- BFS는 되돌아 오지 않는다. 
  연결된 모든 노드를 더해나가는 방식임.
- DFS는 하나하나 따라가보는 방식이다.
  끝에 도달하면, 끝난다.

이문제는 시작노드가 정해져 있어서, 한 시작노드만 탐색하면 된다. 방문노드를 초기화할 필요가 없다.
이 다음 문제, ABCDE의 경우 모든 노드를 시작으로 돌려봐야하기에, 방문노드를 초기화하는 과정이 필요하다.  

답안

```python
n, m, v = map(int, input().split())
rel = [[] for _ in range(n+1)] # 노드를 1,2,3.. 이렇게 하기 때문에 0번은 비워줌.
visited = []

for _ in range(m):
    a, b = map(int, input().split())
    rel[a].append(b)
    rel[b].append(a)

def bfs(x):
    visited.append(x)
    for a in visited:
        for b in sorted(rel[a]):
            if b not in visited:
                visited.append(b)
    return visited

def dfs(x):
    visited.append(x)
    for a in sorted(rel[x]):
        if a not in visited:
            dfs(a)
    return visited

print(*dfs(v))
visited = []
print(*bfs(v))
```



### ABCDE

[문제](https://www.acmicpc.net/problem/13023)

문제 이해가 잘 안될 수 있다. [여기를 참고](https://grini25.tistory.com/110)
간단하게 설명하면, 주어진 관계를 그래프로 그렸을때, 
노드를 중복하지 않고 이어서, 5개를 이을 수 있는지의 여부를 출력하는 문제이다.

모든 경우를 살펴야 하기에 DFS 알고리즘으로 풀 수 있다. 

n개의 노드가 주어지면, 모든 노드를 시작노드를 돌려보고, 연결이 4번이 되면 1을 출력, 안되면, 0을 출력한다.
방문한 노드는 True를 표시하고, 방문하지 않은 노드에 대해서는 재귀로 돌게 한다. 

**모든 노드를 확인해야하기에, 되돌아올때는 지나온 경로의 visited를 다시 False로 바꿔줘야한다.**

재귀가 생길때마다 카운트를 늘려간다.
카운트가 목표한 4가 되면 1을 출력, 
모든 노드를 돌아도 없을때는 0을 출력한다.

답안

```python
n, m = map(int, input().split())
rel = [[] for _ in range(n)]
visited = [False for _ in range(n)]

for _ in range(m):
    a, b = map(int, input().split())
    rel[a].append(b)
    rel[b].append(a)

def dfs(count, node):
    visited[node] = True
    if count == 4:
        print(1)
        exit()
    for x in rel[node]:
        if not visited[x]:
            dfs(count+1, x)
            visited[x] = False

for i in range(n):
    dfs(0, i)
    visited[i] = False
print(0)
```



### 연결요소의 개수

[문제](https://www.acmicpc.net/problem/11724)

그래프가 주어졌을때, 연결요소의 개수를 구하는 프로그램.

처음에는 전부다 검색을 해봐야하니, ABCDE처럼 visited를 초기화하는 과정이 필요하다고 생각했다. 
근데, 이미 visited한 곳은 하나의 연결요소에 속하기 때문에 다시 중복해서 카운팅하면 안된다. 

예를 들어, 다음과 같은 그래프가 주어졌을때, 

```
1, 2, 5
2, 1, 3, 5, 4
3, 2, 4
4, 3, 6, 5, 2
5, 2, 1, 4
6, 4
```

visited가 채워지는 순서는 1, 2, 3, 4, 6, 5 이다. 

1, 2, 3, 4, 6까지는 납득이 간다. 그냥 False인 요소를 재귀한 것이기 때문에.
하지만, 마지막에 5는 6과 연결관계도 없는데, 왜 True가 되는 걸까?

이게 가능한 이유는 

```python
def dfs(x):
    visited[x] = True
    for e in rel[x]:
        if not visited[e]:
            dfs(e)
```

dfs 함수에서 `for e in rel[x]:` 부분. 
1=> 2=> 3=> 4=> 6 
그리고 6에서는 아무일도 일어나지 않는다. dfs로 재귀가 없음.
그렇기에 4의 for문으로 돌아와서 나머지 요소들을 순회하는 것이다. 

그래서 5가 채워지는 거임.

문제가 연결된 요소의 개수를 구하는 것이기에, 위와 같은 알고리즘으로 특정 노드와 연결된 모든 요소를 True로 만들 수 있다. 

답안

```python
import sys
sys.setrecursionlimit(5000) # 1000 재귀제한때문에 런타임에러가 난다. 올려줘야함.
input = sys.stdin.readline # 안하면 시간초과남.

def dfs(x):
    visited[x] = True
    for e in rel[x]:
        if not visited[e]:
            dfs(e)

n, m = map(int, input().split())
rel = [[] for _ in range(n+1)]
visited = [False for _ in range(n+1)]

for _ in range(m):
    u, v = map(int, input().split())
    rel[u].append(v)
    rel[v].append(u)

count = 0

for i in range(1, n+1):
    if not visited[i]:
        dfs(i)
        count += 1

print(count)
```



### 이분그래프

[문제](https://www.acmicpc.net/problem/1707)

이분 그래프에 대한 설명은 [위키백과를 참고](https://en.wikipedia.org/wiki/Bipartite_graph)
쉽게 말하면, 그래프의 노드를 빨간색, 파란색으로 칠할때, 인접한 노드끼리는 다른 색으로 칠할 수 있는지의 여부를 출력하는 문제이다.

어떻게 풀어야할지 감도 안오는 문제였다. [블로그](https://suri78.tistory.com/125)를 참고해서 코드를 해석해보며 공부했다. 

이 문제는 그래프 노드를 탐색하면서, visited로 표시했던 지난 문제와는 달리, 색깔을 저장하는 과정을 거친다. 
그리고, 연결된 노드의 색이 같을 경우에는 NO를 출력, 모두 다를 경우에는 YES를 출력한다. 

**연결된 노드의 관계가 중요한 문제이기에, bfs로 푸는 것이 좋다.** 

> 1번 노드의 색을 1로 칠하고, 
> 1번에 연결된 노드의 색을 2로 칠하고, 큐에 추가한다. 
> 큐에 추가된 노드들을 먼저들어온 애들의 연결된 노드를 확인한다.
> 아직 방문하지 않은 노드는 현재 노드와 다른 색을 부여해서 큐에 삽입하고,
> 방문해서 색을 가진 노드에 대해서는 현재노드의 색과 같은지 다른지를 본다. 
>
> 같으면, 탐색을 중단하고 NO를 출력한다. 
> 다르면, 큐가 빌때까지 탐색을 계속한다.  

답안

```python
from collections import deque 
import sys 
input = sys.stdin.readline

for _ in range(int(input())): 
    v, e = map(int, input().split()) # 정점, 간선
    link = [[] for _ in range(v+1)] 
    for _ in range(e): 
        a, b = map(int, input().split()) 
        link[a].append(b) 
        link[b].append(a) 
        
    color = [0] * (v+1) 
    STOP = False 
    
    for i in range(1, v+1): # for로 모든 노드를 시작점으로 해보는 이유는, 연결되지 않은 노드가 있을 수 있기 때문이다.
        if STOP: break 
        if color[i] > 0: continue 
        
        color[i] = 1 
        queue = deque([i]) 
        
        while queue and not STOP: 
            q = queue.popleft() 
            c = 3 - color[q] 
            # 현재 노드와 다른 색을 설정한다. 
            # 현재 노드가 1이면 2를, 2면 1로 설정.
            
            for k in link[q]: 
                if color[k] == 0: 
                    # 방문하지 않은 노드는 현재 노드와 다른 색을 칠해서, queue에 추가한다.
                    color[k] = c 
                    queue.append(k) 
                elif color[k] == color[q]:  
                    # 연결된 정점의 색이 같은 경우 => 'NO' 출력
                    STOP = True 
                    break 
    
    print("YES" if not STOP else "NO")
```

